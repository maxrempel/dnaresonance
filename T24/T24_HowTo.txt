Попробую описать алгоритм работы программы T24_CPP

Исходники лежат на https://github.com/maxrempel/dnaresonance/tree/master/T24/T24_CPP

Задача была поставлена: исходя из определенных данных, построить и вывести некоторые результаты, а затем попробовать сделать немного другое или немного по-другому, и так несколько раз. Поэтому читать код, наверно, не очень легко. К тому же многие изменения делались на скорую руку. Правда, код откомментирован (в меру) и имена переменных более-менее понятны, ну и git log дает представление об истории изменений.

Все подробности сейчас я перечислять не буду, прямо сейчас меня попросили, цитирую: "в чем секрет, как ты сделал чтобы программа быстро находила повторы?"

Задача была сформулирована так: нужно найти повторы не меньше N раз последовательностей длины не меньше L.

Нетрудно видеть, что если последовательность длины S>1 повторяется R раз, то и всякая ее подпоследовательность (соответственно, длины <S) повторяется не меньше R раз. В частности, это верно в отношении всякого ее префикса (т.е. начала подпоследовательности). 

Поэтому поиск идет в два этапа. 

На первом этапе мы находим подпоследовательности длиной ровно L, которые повторяются не менее N раз. 

На втором этапе мы по очереди пытаемся удлинить каждую из найденных подпоследовательностей на одну букву, пока у нас все еще есть такие подпоследовательности с не менее чем N копиями. Т.е. на каждой итерации мы смотрим на только что найденные такие последовательности длиной M, удлиняем каждую из них на одну букву, в конце итерации подсчитываем количество копий, и оставляем только те,у которых копий не меньше N. Ну а когда на очередной итерации таких новых последовательностей не обнаруживается, мы останавливаемся.

Имплементация

На первом этапе подстроки длиной L начиная с позиции 0, 1, ... записываются в dictionary (map, словарь, хэш, ассоциативный массив, etc), где каждой последовательности букв соответствует количество ее повторений в исходной последовательности. Точнее, последовательности соответствует список позиций, где такая последовательность начинается. На первом этапе важно только количество (т.е. длина каждого списка), но на следующем важны сами позиции. См. seq2positions

На втором этапе новый словарь (etc) строится на основе предыдущего: сканируются ключи словаря (т.е. последовательности предыдущей длины), про эти последовательность сразу известно, где они начинаются, удлиняем на одну букву и строим новый такой же словарь для текущей длины. На самом деле, для удобства мы "переворачиваем" словарь: строим другой, отображающий начало последовательности "предыдущей длины" на последовательность (start2seq), a seq2positions каждый раз пересчитывается. Результаты каждой итерации записываются в еще один словарь, который каждой длине последовательности ставит в соответствие соответствующий словарь (length2map).

В исходниках T24_CPP много чего еще делается, в том числе посредине описанных действий. Но этого описания должно хватить.
